"""
Bill.com API service for invoice data integration.

This service provides Bill.com API authentication, session management,
and data operations for the Multi-Agent Custom Automation Engine (MACAE).
"""

import os
import json
import asyncio
import logging
from typing import Dict, List, Optional, Any, Union
from datetime import datetime, timedelta, timezone
import httpx
from dataclasses import dataclass, asdict
import time
import random
import uuid
from contextlib import contextmanager

# Configure structured logging
logger = logging.getLogger(__name__)

# Error classification constants
class ErrorType:
    """Error type classifications for Bill.com API operations."""
    AUTHENTICATION = "authentication_error"
    AUTHORIZATION = "authorization_error"
    RATE_LIMIT = "rate_limit_error"
    NETWORK = "network_error"
    TIMEOUT = "timeout_error"
    SERVER = "server_error"
    CLIENT = "client_error"
    CONFIGURATION = "configuration_error"
    VALIDATION = "validation_error"
    UNKNOWN = "unknown_error"

class ErrorSeverity:
    """Error severity levels."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class BillComConfig:
    """Bill.com API configuration."""
    base_url: str
    username: str
    password: str
    organization_id: str
    dev_key: str
    environment: str = "stage"  # stage or production
    
    @classmethod
    def from_env(cls) -> 'BillComConfig':
        """Load configuration from environment variables."""
        return cls(
            base_url=os.getenv("BILL_COM_BASE_URL", "https://gateway.stage.bill.com"),
            username=os.getenv("BILL_COM_USERNAME"),
            password=os.getenv("BILL_COM_PASSWORD"),
            organization_id=os.getenv("BILL_COM_ORG_ID"),
            dev_key=os.getenv("BILL_COM_DEV_KEY"),
            environment=os.getenv("BILL_COM_ENVIRONMENT", "stage")
        )
    
    def validate(self) -> bool:
        """Validate that all required fields are present."""
        required_fields = [self.username, self.password, self.organization_id, self.dev_key]
        return all(field is not None for field in required_fields)


@dataclass
class BillComSession:
    """Bill.com API session information."""
    session_id: str
    organization_id: str
    user_id: str
    expires_at: datetime
    
    def is_expired(self) -> bool:
        """Check if session is expired (with 5 minute buffer)."""
        return datetime.now(timezone.utc) >= (self.expires_at - timedelta(minutes=5))


class BillComAPIService:
    """Service for Bill.com API operations with comprehensive error handling and logging."""
    
    def __init__(self, plan_id: Optional[str] = None, agent: Optional[str] = None):
        self.config = BillComConfig.from_env()
        self.session: Optional[BillComSession] = None
        self._http_client: Optional[httpx.AsyncClient] = None
        
        # Context for structured logging
        self.plan_id = plan_id or str(uuid.uuid4())
        self.agent = agent or "unknown"
        self.operation_id: Optional[str] = None
        
        # Performance tracking
        self._operation_start_time: Optional[float] = None
        self._api_call_count = 0
        self._total_response_time = 0.0
    
    async def __aenter__(self):
        """Async context manager entry."""
        self._http_client = httpx.AsyncClient()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        if self._http_client:
            await self._http_client.aclose()
    
    @contextmanager
    def _operation_context(self, operation: str):
        """Context manager for tracking operation performance and logging."""
        self.operation_id = str(uuid.uuid4())
        self._operation_start_time = time.time()
        
        self._log_structured(
            level="info",
            message=f"Starting Bill.com operation: {operation}",
            operation=operation,
            event_type="operation_start"
        )
        
        try:
            yield
        except Exception as e:
            self._log_structured(
                level="error",
                message=f"Bill.com operation failed: {operation}",
                operation=operation,
                event_type="operation_error",
                error_type=self._classify_error(e),
                error_message=str(e)
            )
            raise
        finally:
            if self._operation_start_time:
                duration = time.time() - self._operation_start_time
                self._log_structured(
                    level="info",
                    message=f"Completed Bill.com operation: {operation}",
                    operation=operation,
                    event_type="operation_complete",
                    duration_ms=round(duration * 1000, 2)
                )
    
    def _log_structured(self, level: str, message: str, **kwargs):
        """Log with structured context information."""
        log_data = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "service": "bill_com",
            "plan_id": self.plan_id,
            "agent": self.agent,
            "operation_id": self.operation_id,
            "organization_id": self.config.organization_id if self.config else None,
            "session_id": self.session.session_id[:8] + "..." if self.session else None,
            **kwargs
        }
        
        # Remove sensitive data
        safe_log_data = self._sanitize_log_data(log_data)
        
        # Format log message with context
        context_str = " | ".join([f"{k}={v}" for k, v in safe_log_data.items() if v is not None])
        formatted_message = f"{message} | {context_str}"
        
        # Log at appropriate level
        getattr(logger, level)(formatted_message)
    
    def _sanitize_log_data(self, log_data: Dict[str, Any]) -> Dict[str, Any]:
        """Remove sensitive information from log data."""
        sensitive_keys = ["password", "devKey", "dev_key", "session_id", "sessionId"]
        sanitized = {}
        
        for key, value in log_data.items():
            if key.lower() in [k.lower() for k in sensitive_keys]:
                if value:
                    sanitized[key] = "***REDACTED***"
                else:
                    sanitized[key] = value
            elif isinstance(value, dict):
                sanitized[key] = self._sanitize_log_data(value)
            else:
                sanitized[key] = value
        
        return sanitized
    
    def _classify_error(self, error: Exception) -> str:
        """Classify error type for structured logging."""
        if isinstance(error, httpx.TimeoutException):
            return ErrorType.TIMEOUT
        elif isinstance(error, httpx.NetworkError):
            return ErrorType.NETWORK
        elif isinstance(error, httpx.HTTPStatusError):
            status_code = error.response.status_code
            if status_code == 401:
                return ErrorType.AUTHENTICATION
            elif status_code == 403:
                return ErrorType.AUTHORIZATION
            elif status_code == 429:
                return ErrorType.RATE_LIMIT
            elif 400 <= status_code < 500:
                return ErrorType.CLIENT
            elif 500 <= status_code < 600:
                return ErrorType.SERVER
        elif "configuration" in str(error).lower():
            return ErrorType.CONFIGURATION
        elif "validation" in str(error).lower():
            return ErrorType.VALIDATION
        
        return ErrorType.UNKNOWN
    
    def _get_error_severity(self, error_type: str) -> str:
        """Determine error severity based on error type."""
        severity_map = {
            ErrorType.AUTHENTICATION: ErrorSeverity.HIGH,
            ErrorType.AUTHORIZATION: ErrorSeverity.HIGH,
            ErrorType.CONFIGURATION: ErrorSeverity.CRITICAL,
            ErrorType.RATE_LIMIT: ErrorSeverity.MEDIUM,
            ErrorType.NETWORK: ErrorSeverity.MEDIUM,
            ErrorType.TIMEOUT: ErrorSeverity.MEDIUM,
            ErrorType.SERVER: ErrorSeverity.HIGH,
            ErrorType.CLIENT: ErrorSeverity.LOW,
            ErrorType.VALIDATION: ErrorSeverity.LOW,
            ErrorType.UNKNOWN: ErrorSeverity.MEDIUM
        }
        return severity_map.get(error_type, ErrorSeverity.MEDIUM)
    
    def _is_temporary_failure(self, error_type: str) -> bool:
        """Determine if error is temporary and retryable."""
        temporary_errors = {
            ErrorType.NETWORK,
            ErrorType.TIMEOUT,
            ErrorType.SERVER,
            ErrorType.RATE_LIMIT
        }
        return error_type in temporary_errors
    
    def _get_missing_config_fields(self) -> List[str]:
        """Get list of missing configuration fields."""
        missing = []
        if not self.config.username:
            missing.append("username")
        if not self.config.password:
            missing.append("password")
        if not self.config.organization_id:
            missing.append("organization_id")
        if not self.config.dev_key:
            missing.append("dev_key")
        return missing
    
    async def authenticate(self) -> bool:
        """
        Authenticate with Bill.com API and establish session.
        
        Returns:
            bool: True if authentication successful
        """
        with self._operation_context("authenticate"):
            if not self.config.validate():
                self._log_structured(
                    level="error",
                    message="Bill.com configuration validation failed",
                    event_type="authentication_failed",
                    error_type=ErrorType.CONFIGURATION,
                    error_severity=ErrorSeverity.CRITICAL,
                    missing_fields=self._get_missing_config_fields()
                )
                return False
            
            login_url = f"{self.config.base_url}/connect/v3/login"
            login_data = {
                "username": self.config.username,
                "password": self.config.password,
                "organizationId": self.config.organization_id,
                "devKey": self.config.dev_key
            }
            
            start_time = time.time()
            
            try:
                self._log_structured(
                    level="info",
                    message="Initiating Bill.com authentication",
                    event_type="authentication_start",
                    base_url=self.config.base_url,
                    environment=self.config.environment,
                    username=self.config.username  # Will be sanitized
                )
                
                response = await self._http_client.post(
                    login_url,
                    json=login_data,
                    headers={"Content-Type": "application/json"},
                    timeout=30.0
                )
                
                response_time = time.time() - start_time
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Create session object
                    self.session = BillComSession(
                        session_id=data["sessionId"],
                        organization_id=data["organizationId"],
                        user_id=data["userId"],
                        expires_at=datetime.now(timezone.utc) + timedelta(hours=2)  # Assume 2 hour session
                    )
                    
                    self._log_structured(
                        level="info",
                        message="Bill.com authentication successful",
                        event_type="authentication_success",
                        response_time_ms=round(response_time * 1000, 2),
                        session_expires_at=self.session.expires_at.isoformat(),
                        user_id=self.session.user_id
                    )
                    return True
                else:
                    error_text = response.text
                    error_type = ErrorType.AUTHENTICATION if response.status_code == 401 else ErrorType.CLIENT
                    
                    self._log_structured(
                        level="error",
                        message="Bill.com authentication failed",
                        event_type="authentication_failed",
                        error_type=error_type,
                        error_severity=self._get_error_severity(error_type),
                        status_code=response.status_code,
                        response_time_ms=round(response_time * 1000, 2),
                        error_details=error_text[:500]  # Limit error text length
                    )
                    return False
                        
            except Exception as e:
                response_time = time.time() - start_time
                error_type = self._classify_error(e)
                
                self._log_structured(
                    level="error",
                    message="Bill.com authentication error",
                    event_type="authentication_error",
                    error_type=error_type,
                    error_severity=self._get_error_severity(error_type),
                    response_time_ms=round(response_time * 1000, 2),
                    error_message=str(e),
                    is_retryable=self._is_temporary_failure(error_type)
                )
                return False
    
    async def ensure_authenticated(self) -> bool:
        """
        Ensure we have a valid authenticated session.
        
        Returns:
            bool: True if session is valid/established
        """
        if not self.session or self.session.is_expired():
            return await self.authenticate()
        return True
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """Get performance metrics for the service."""
        avg_response_time = (
            self._total_response_time / self._api_call_count 
            if self._api_call_count > 0 else 0
        )
        
        return {
            "api_call_count": self._api_call_count,
            "total_response_time_seconds": round(self._total_response_time, 3),
            "average_response_time_ms": round(avg_response_time * 1000, 2),
            "session_active": self.session is not None,
            "session_expired": self.session.is_expired() if self.session else None,
            "organization_id": self.config.organization_id if self.config else None
        }
    
    async def make_api_call(
        self,
        endpoint: str,
        method: str = "GET",
        data: Optional[Dict] = None,
        params: Optional[Dict] = None,
        max_retries: int = 3
    ) -> Optional[Dict]:
        """Make authenticated API call to Bill.com with comprehensive error handling and logging."""
        operation_name = f"{method} {endpoint}"
        
        with self._operation_context(f"api_call_{operation_name}"):
            if not await self.ensure_authenticated():
                self._log_structured(
                    level="error",
                    message="Cannot make API call - authentication failed",
                    event_type="api_call_failed",
                    error_type=ErrorType.AUTHENTICATION,
                    endpoint=endpoint,
                    method=method
                )
                return None
            
            url = f"{self.config.base_url}{endpoint}"
            
            # Add session ID to request
            if params is None:
                params = {}
            params["sessionId"] = self.session.session_id
            
            headers = {"Content-Type": "application/json"}
            
            # Track API call metrics
            self._api_call_count += 1
            total_start_time = time.time()
            
            # Retry loop with exponential backoff
            for attempt in range(max_retries + 1):
                attempt_start_time = time.time()
                
                try:
                    if attempt > 0:
                        base_delay = 2 ** (attempt - 1)
                        jitter = random.uniform(0.1, 0.3)
                        delay = base_delay + jitter
                        
                        self._log_structured(
                            level="info",
                            message="Retrying Bill.com API call",
                            event_type="api_retry",
                            endpoint=endpoint,
                            method=method,
                            attempt=attempt,
                            max_retries=max_retries,
                            delay_seconds=round(delay, 2)
                        )
                        
                        await asyncio.sleep(delay)
                    
                    response = await self._http_client.request(
                        method=method,
                        url=url,
                        json=data,
                        params=params,
                        headers=headers,
                        timeout=30.0
                    )
                    
                    attempt_time = time.time() - attempt_start_time
                    
                    # Success case
                    if response.status_code == 200:
                        total_time = time.time() - total_start_time
                        self._total_response_time += total_time
                        
                        response_data = response.json()
                        
                        self._log_structured(
                            level="debug",
                            message="Bill.com API call successful",
                            event_type="api_call_success",
                            endpoint=endpoint,
                            method=method,
                            attempt=attempt + 1,
                            response_time_ms=round(attempt_time * 1000, 2),
                            total_time_ms=round(total_time * 1000, 2),
                            status_code=response.status_code
                        )
                        
                        return response_data
                    
                    # Handle errors
                    elif response.status_code == 401:
                        if await self.authenticate():
                            params["sessionId"] = self.session.session_id
                            continue
                        else:
                            return self._format_error_response(401, "Re-authentication failed", ErrorType.AUTHENTICATION)
                    
                    elif response.status_code == 429:
                        retry_after = self._get_retry_after_delay(response)
                        await asyncio.sleep(retry_after)
                        continue
                    
                    elif 500 <= response.status_code < 600:
                        if attempt < max_retries:
                            continue
                        else:
                            return self._format_error_response(response.status_code, response.text, ErrorType.SERVER)
                    
                    else:
                        return self._format_error_response(response.status_code, response.text, ErrorType.CLIENT)
                        
                except asyncio.TimeoutError:
                    if attempt < max_retries:
                        continue
                    else:
                        return self._format_error_response(408, "Request timeout", ErrorType.TIMEOUT)
                        
                except httpx.NetworkError as e:
                    if attempt < max_retries:
                        continue
                    else:
                        return self._format_error_response(503, str(e), ErrorType.NETWORK)
                        
                except Exception as e:
                    if attempt < max_retries:
                        continue
                    else:
                        return self._format_error_response(500, str(e), ErrorType.UNKNOWN)
            
            return None
    
    def _get_retry_after_delay(self, response: httpx.Response) -> float:
        """Extract retry delay from rate limit response."""
        retry_after = response.headers.get("Retry-After")
        if retry_after:
            try:
                return float(retry_after)
            except ValueError:
                pass
        return 60.0
    
    def _format_error_response(self, status_code: int, error_text: str, error_type: str) -> Dict[str, Any]:
        """Format structured error response with comprehensive error information."""
        error_response = {
            "error": True,
            "error_type": error_type,
            "error_severity": self._get_error_severity(error_type),
            "status_code": status_code,
            "message": error_text,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "retryable": self._is_temporary_failure(error_type),
            "context": {
                "plan_id": self.plan_id,
                "agent": self.agent,
                "operation_id": self.operation_id,
                "organization_id": self.config.organization_id if self.config else None
            }
        }
        
        self._log_structured(
            level="debug",
            message="Created structured error response",
            event_type="error_response_created",
            error_type=error_type,
            error_severity=error_response["error_severity"],
            status_code=status_code,
            retryable=error_response["retryable"]
        )
        
        return error_response
    
    # Hardcoded query functions for Phase 1
    
    async def get_invoices(
        self,
        limit: int = 50,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        vendor_id: Optional[str] = None,
        status: Optional[str] = None
    ) -> List[Dict]:
        """Get invoices with optional filtering."""
        params = {"max": limit}
        
        if start_date:
            params["startDate"] = start_date
        if end_date:
            params["endDate"] = end_date
        if vendor_id:
            params["vendorId"] = vendor_id
        if status:
            params["status"] = status
        
        response = await self.make_api_call("/v3/invoices", params=params)
        
        if response and response.get("error"):
            self._log_structured(
                level="error",
                message="Failed to get invoices",
                event_type="get_invoices_failed",
                error_type=response.get("error_type", ErrorType.UNKNOWN),
                error_message=response.get("message", "Unknown error")
            )
            return []
        
        if response and "response_data" in response:
            return response["response_data"]
        
        return []
    
    async def get_invoice_by_id(self, invoice_id: str) -> Optional[Dict]:
        """Get detailed invoice information by ID."""
        response = await self.make_api_call(f"/v3/invoices/{invoice_id}")
        
        if response and response.get("error"):
            self._log_structured(
                level="error",
                message=f"Failed to get invoice {invoice_id}",
                event_type="get_invoice_by_id_failed",
                invoice_id=invoice_id,
                error_type=response.get("error_type", ErrorType.UNKNOWN),
                error_message=response.get("message", "Unknown error")
            )
            return None
        
        if response and "response_data" in response:
            return response["response_data"]
        
        return None
    
    async def get_complete_invoice_details(self, invoice_id: str) -> Optional[Dict]:
        """
        Get complete invoice details including line items, payments, attachments, and approval workflow.
        
        Args:
            invoice_id: Bill.com invoice ID
            
        Returns:
            Complete invoice details with all related data or None if not found
        """
        with self._operation_context(f"get_complete_invoice_details_{invoice_id}"):
            try:
                # Get basic invoice details
                invoice_response = await self.make_api_call(f"/v3/invoices/{invoice_id}")
                
                if not invoice_response or invoice_response.get("error"):
                    self._log_structured(
                        level="error",
                        message=f"Failed to get basic invoice details for {invoice_id}",
                        event_type="complete_invoice_details_failed",
                        invoice_id=invoice_id,
                        error_type=invoice_response.get("error_type", ErrorType.UNKNOWN) if invoice_response else ErrorType.UNKNOWN,
                        error_message=invoice_response.get("message", "No response") if invoice_response else "No response"
                    )
                    return None
                
                invoice_data = invoice_response.get("response_data", {})
                
                # Concurrently fetch related data
                tasks = []
                
                # Get payment history
                tasks.append(self._get_invoice_payments_safe(invoice_id))
                
                # Get line items (if not already included)
                if not invoice_data.get("lineItems"):
                    tasks.append(self._get_invoice_line_items_safe(invoice_id))
                else:
                    tasks.append(asyncio.create_task(self._return_value(invoice_data.get("lineItems", []))))
                
                # Get attachments
                tasks.append(self._get_invoice_attachments_safe(invoice_id))
                
                # Get approval workflow
                tasks.append(self._get_invoice_approval_workflow_safe(invoice_id))
                
                # Execute all requests concurrently
                payments, line_items, attachments, approval_workflow = await asyncio.gather(*tasks)
                
                # Build complete invoice details
                complete_details = self._build_complete_invoice_details(
                    invoice_data, payments, line_items, attachments, approval_workflow
                )
                
                self._log_structured(
                    level="info",
                    message=f"Successfully retrieved complete invoice details for {invoice_id}",
                    event_type="complete_invoice_details_success",
                    invoice_id=invoice_id,
                    has_payments=len(payments) > 0,
                    has_line_items=len(line_items) > 0,
                    has_attachments=len(attachments) > 0,
                    has_approval_workflow=approval_workflow is not None
                )
                
                return complete_details
                
            except Exception as e:
                error_type = self._classify_error(e)
                self._log_structured(
                    level="error",
                    message=f"Error retrieving complete invoice details for {invoice_id}",
                    event_type="complete_invoice_details_error",
                    invoice_id=invoice_id,
                    error_type=error_type,
                    error_message=str(e)
                )
                return None
    
    async def _get_invoice_payments_safe(self, invoice_id: str) -> List[Dict]:
        """Safely get invoice payments with error handling."""
        try:
            return await self.get_invoice_payments(invoice_id)
        except Exception as e:
            self._log_structured(
                level="warning",
                message=f"Failed to get payments for invoice {invoice_id}",
                event_type="invoice_payments_fetch_failed",
                invoice_id=invoice_id,
                error_message=str(e)
            )
            return []
    
    async def _get_invoice_line_items_safe(self, invoice_id: str) -> List[Dict]:
        """Safely get invoice line items with error handling."""
        try:
            response = await self.make_api_call(f"/v3/invoices/{invoice_id}/lineItems")
            if response and "response_data" in response:
                return response["response_data"]
            return []
        except Exception as e:
            self._log_structured(
                level="warning",
                message=f"Failed to get line items for invoice {invoice_id}",
                event_type="invoice_line_items_fetch_failed",
                invoice_id=invoice_id,
                error_message=str(e)
            )
            return []
    
    async def _get_invoice_attachments_safe(self, invoice_id: str) -> List[Dict]:
        """Safely get invoice attachments with error handling."""
        try:
            response = await self.make_api_call(f"/v3/invoices/{invoice_id}/attachments")
            if response and "response_data" in response:
                return response["response_data"]
            return []
        except Exception as e:
            self._log_structured(
                level="warning",
                message=f"Failed to get attachments for invoice {invoice_id}",
                event_type="invoice_attachments_fetch_failed",
                invoice_id=invoice_id,
                error_message=str(e)
            )
            return []
    
    async def _get_invoice_approval_workflow_safe(self, invoice_id: str) -> Optional[Dict]:
        """Safely get invoice approval workflow with error handling."""
        try:
            response = await self.make_api_call(f"/v3/invoices/{invoice_id}/approvals")
            if response and "response_data" in response:
                return response["response_data"]
            return None
        except Exception as e:
            self._log_structured(
                level="warning",
                message=f"Failed to get approval workflow for invoice {invoice_id}",
                event_type="invoice_approval_workflow_fetch_failed",
                invoice_id=invoice_id,
                error_message=str(e)
            )
            return None
    
    async def _return_value(self, value):
        """Helper to return a value as an async task."""
        return value
    
    def _build_complete_invoice_details(
        self,
        invoice_data: Dict,
        payments: List[Dict],
        line_items: List[Dict],
        attachments: List[Dict],
        approval_workflow: Optional[Dict]
    ) -> Dict:
        """
        Build complete invoice details with field availability indicators.
        
        Args:
            invoice_data: Basic invoice data
            payments: Payment history
            line_items: Invoice line items
            attachments: Invoice attachments
            approval_workflow: Approval workflow data
            
        Returns:
            Complete invoice details with availability indicators
        """
        # Calculate remaining balance
        total_amount = float(invoice_data.get("amount", 0))
        total_payments = sum(float(payment.get("amount", 0)) for payment in payments)
        remaining_balance = total_amount - total_payments
        
        # Build complete details
        complete_details = {
            # Basic invoice information
            "id": invoice_data.get("id"),
            "invoice_number": invoice_data.get("invoiceNumber"),
            "vendor_name": invoice_data.get("vendorName"),
            "vendor_id": invoice_data.get("vendorId"),
            "invoice_date": invoice_data.get("invoiceDate"),
            "due_date": invoice_data.get("dueDate"),
            "total_amount": total_amount,
            "currency": invoice_data.get("currency", "USD"),
            "status": invoice_data.get("status"),
            "description": invoice_data.get("description", ""),
            
            # Financial details
            "remaining_balance": remaining_balance,
            "total_payments": total_payments,
            "is_fully_paid": remaining_balance <= 0.01,  # Account for floating point precision
            
            # Line items
            "line_items": self._format_line_items(line_items),
            "line_items_count": len(line_items),
            
            # Payment history
            "payment_history": self._format_payment_history(payments),
            "payment_count": len(payments),
            
            # Attachments
            "attachments": self._format_attachments(attachments),
            "attachment_count": len(attachments),
            
            # Approval workflow
            "approval_workflow": self._format_approval_workflow(approval_workflow),
            "approval_status": self._get_approval_status(approval_workflow),
            
            # Timestamps
            "created_time": invoice_data.get("createdTime"),
            "updated_time": invoice_data.get("updatedTime"),
            
            # Field availability indicators
            "data_availability": {
                "basic_info": True,
                "line_items": len(line_items) > 0,
                "payment_history": len(payments) > 0,
                "attachments": len(attachments) > 0,
                "approval_workflow": approval_workflow is not None,
                "financial_calculations": True
            },
            
            # Metadata
            "retrieved_at": datetime.now(timezone.utc).isoformat(),
            "data_completeness_score": self._calculate_completeness_score(
                invoice_data, line_items, payments, attachments, approval_workflow
            )
        }
        
        return complete_details
    
    def _format_line_items(self, line_items: List[Dict]) -> List[Dict]:
        """Format line items with consistent structure."""
        formatted_items = []
        for item in line_items:
            formatted_items.append({
                "id": item.get("id"),
                "description": item.get("description", ""),
                "quantity": float(item.get("quantity", 0)),
                "unit_price": float(item.get("unitPrice", 0)),
                "total_amount": float(item.get("amount", 0)),
                "account_code": item.get("accountCode"),
                "tax_amount": float(item.get("taxAmount", 0)) if item.get("taxAmount") else None,
                "department": item.get("department"),
                "project": item.get("project")
            })
        return formatted_items
    
    def _format_payment_history(self, payments: List[Dict]) -> List[Dict]:
        """Format payment history with consistent structure."""
        formatted_payments = []
        for payment in payments:
            formatted_payments.append({
                "id": payment.get("id"),
                "payment_date": payment.get("paymentDate"),
                "amount": float(payment.get("amount", 0)),
                "payment_method": payment.get("paymentMethod"),
                "reference_number": payment.get("referenceNumber"),
                "status": payment.get("status"),
                "created_time": payment.get("createdTime"),
                "notes": payment.get("notes", "")
            })
        
        # Sort by payment date (most recent first)
        formatted_payments.sort(
            key=lambda x: x.get("payment_date", ""), 
            reverse=True
        )
        
        return formatted_payments
    
    def _format_attachments(self, attachments: List[Dict]) -> List[Dict]:
        """Format attachments with consistent structure."""
        formatted_attachments = []
        for attachment in attachments:
            formatted_attachments.append({
                "id": attachment.get("id"),
                "filename": attachment.get("fileName"),
                "file_size": attachment.get("fileSize"),
                "content_type": attachment.get("contentType"),
                "download_url": attachment.get("downloadUrl"),
                "upload_date": attachment.get("uploadDate"),
                "uploaded_by": attachment.get("uploadedBy"),
                "description": attachment.get("description", "")
            })
        return formatted_attachments
    
    def _format_approval_workflow(self, approval_workflow: Optional[Dict]) -> Optional[Dict]:
        """Format approval workflow with consistent structure."""
        if not approval_workflow:
            return None
        
        return {
            "current_status": approval_workflow.get("status"),
            "approval_steps": approval_workflow.get("approvalSteps", []),
            "current_approver": approval_workflow.get("currentApprover"),
            "approval_history": approval_workflow.get("approvalHistory", []),
            "workflow_started": approval_workflow.get("workflowStarted"),
            "workflow_completed": approval_workflow.get("workflowCompleted"),
            "requires_approval": approval_workflow.get("requiresApproval", False)
        }
    
    def _get_approval_status(self, approval_workflow: Optional[Dict]) -> str:
        """Get simplified approval status."""
        if not approval_workflow:
            return "no_workflow"
        
        status = approval_workflow.get("status", "").lower()
        
        if status in ["approved", "complete"]:
            return "approved"
        elif status in ["pending", "in_progress"]:
            return "pending"
        elif status in ["rejected", "denied"]:
            return "rejected"
        else:
            return "unknown"
    
    def _calculate_completeness_score(
        self,
        invoice_data: Dict,
        line_items: List[Dict],
        payments: List[Dict],
        attachments: List[Dict],
        approval_workflow: Optional[Dict]
    ) -> float:
        """
        Calculate data completeness score (0.0 to 1.0).
        
        Returns:
            Completeness score where 1.0 means all data is available
        """
        score = 0.0
        total_weight = 0.0
        
        # Basic invoice data (weight: 0.4)
        basic_fields = ["id", "invoiceNumber", "vendorName", "amount", "status"]
        basic_score = sum(1 for field in basic_fields if invoice_data.get(field)) / len(basic_fields)
        score += basic_score * 0.4
        total_weight += 0.4
        
        # Line items (weight: 0.2)
        if len(line_items) > 0:
            score += 0.2
        total_weight += 0.2
        
        # Payment history (weight: 0.2)
        if len(payments) > 0:
            score += 0.2
        total_weight += 0.2
        
        # Attachments (weight: 0.1)
        if len(attachments) > 0:
            score += 0.1
        total_weight += 0.1
        
        # Approval workflow (weight: 0.1)
        if approval_workflow:
            score += 0.1
        total_weight += 0.1
        
        return round(score / total_weight if total_weight > 0 else 0.0, 2)
    
    async def search_invoices_by_number(self, invoice_number: str) -> List[Dict]:
        """Search invoices by invoice number."""
        params = {"invoiceNumber": invoice_number}
        response = await self.make_api_call("/v3/invoices/search", params=params)
        
        if response and response.get("error"):
            self._log_structured(
                level="error",
                message=f"Failed to search invoices by number {invoice_number}",
                event_type="search_invoices_failed",
                invoice_number=invoice_number,
                error_type=response.get("error_type", ErrorType.UNKNOWN),
                error_message=response.get("message", "Unknown error")
            )
            return []
        
        if response and "response_data" in response:
            return response["response_data"]
        
        return []
    
    async def get_vendors(self, limit: int = 100) -> List[Dict]:
        """Get list of vendors."""
        params = {"max": limit}
        response = await self.make_api_call("/v3/vendors", params=params)
        
        if response and response.get("error"):
            self._log_structured(
                level="error",
                message="Failed to get vendors",
                event_type="get_vendors_failed",
                error_type=response.get("error_type", ErrorType.UNKNOWN),
                error_message=response.get("message", "Unknown error")
            )
            return []
        
        if response and "response_data" in response:
            return response["response_data"]
        
        return []
    
    async def get_invoice_payments(self, invoice_id: str) -> List[Dict]:
        """Get payment history for an invoice."""
        response = await self.make_api_call(f"/v3/invoices/{invoice_id}/payments")
        
        if response and response.get("error"):
            self._log_structured(
                level="error",
                message=f"Failed to get payments for invoice {invoice_id}",
                event_type="get_invoice_payments_failed",
                invoice_id=invoice_id,
                error_type=response.get("error_type", ErrorType.UNKNOWN),
                error_message=response.get("message", "Unknown error")
            )
            return []
        
        if response and "response_data" in response:
            return response["response_data"]
        
        return []


# Global service instance
_bill_com_service: Optional[BillComAPIService] = None


async def get_bill_com_service(plan_id: Optional[str] = None, agent: Optional[str] = None) -> BillComAPIService:
    """
    Get or create Bill.com service instance with optional context.
    
    Args:
        plan_id: Optional plan ID for logging context
        agent: Optional agent name for logging context
        
    Returns:
        BillComAPIService instance
    """
    global _bill_com_service
    
    if _bill_com_service is None:
        _bill_com_service = BillComAPIService(plan_id=plan_id, agent=agent)
        await _bill_com_service.__aenter__()
    else:
        # Update context if provided
        if plan_id:
            _bill_com_service.plan_id = plan_id
        if agent:
            _bill_com_service.agent = agent
    
    return _bill_com_service 
   
